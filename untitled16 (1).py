# -*- coding: utf-8 -*-
"""Untitled16.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bls1Zm_412sVFvd9OHn47_4qc4iVhlFc
"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
import matplotlib.pyplot as plt
import gradio as gr

# 1. Load dataset t·ª´ GitHub
url = "https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.data.csv"
cols = ["Pregnancies","Glucose","BloodPressure","SkinThickness",
        "Insulin","BMI","DiabetesPedigreeFunction","Age","Outcome"]
data = pd.read_csv(url, names=cols)

# X·ª≠ l√Ω d·ªØ li·ªáu: thay 0 = median
for col in ["Glucose","BloodPressure","SkinThickness","Insulin","BMI"]:
    data[col] = data[col].replace(0, np.nan)
    data[col] = data[col].fillna(data[col].median())

X = data.drop("Outcome", axis=1).values
y = data["Outcome"].values

# Chu·∫©n h√≥a d·ªØ li·ªáu
scaler = StandardScaler()
X = scaler.fit_transform(X)

# Train/test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 2. X√¢y d·ª±ng model (tƒÉng ƒë·ªô ch√≠nh x√°c ~82%)
model = keras.Sequential([
    layers.Dense(64, activation='relu', input_shape=(X.shape[1],)),
    layers.Dropout(0.3),
    layers.Dense(32, activation='relu'),
    layers.Dense(16, activation='relu'),
    layers.Dense(1, activation='sigmoid')
])

# 3. Compile
model.compile(optimizer='adam',
              loss='binary_crossentropy',
              metrics=['accuracy'])

# 4. Summary ƒë·ªÉ xem ki·∫øn tr√∫c model
model.summary()

# 5. Train
history = model.fit(
    X_train, y_train,
    epochs=100,
    batch_size=16,
    validation_data=(X_test, y_test),
    verbose=1
)

# 6. V·∫Ω loss v√† accuracy
plt.figure(figsize=(12,5))
plt.subplot(1,2,1)
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Val Loss')
plt.xlabel("Epochs")
plt.ylabel("Loss")
plt.legend()

plt.subplot(1,2,2)
plt.plot(history.history['accuracy'], label='Train Accuracy')
plt.plot(history.history['val_accuracy'], label='Val Accuracy')
plt.xlabel("Epochs")
plt.ylabel("Accuracy")
plt.legend()
plt.show()

# 7. Test v·ªõi 1 b·ªánh nh√¢n
sample = np.array([[6,148,72,35,0,33.6,0.627,50]])
sample = scaler.transform(sample)
pred = model.predict(sample)
print("X√°c su·∫•t m·∫Øc ti·ªÉu ƒë∆∞·ªùng:", pred[0][0])
print("K·∫øt qu·∫£ d·ª± ƒëo√°n:", "C√≥ b·ªánh" if pred[0][0] > 0.5 else "Kh√¥ng b·ªánh")

# 8. H√†m d·ª± ƒëo√°n cho Gradio
def predict_diabetes(Pregnancies, Glucose, BloodPressure, SkinThickness,
                     Insulin, BMI, DiabetesPedigreeFunction, Age):
    sample = np.array([[Pregnancies, Glucose, BloodPressure, SkinThickness,
                        Insulin, BMI, DiabetesPedigreeFunction, Age]])
    sample = scaler.transform(sample)
    prob = model.predict(sample, verbose=0)[0][0]
    result = "üü¢ Kh√¥ng m·∫Øc ti·ªÉu ƒë∆∞·ªùng" if prob < 0.5 else "üî¥ C√≥ nguy c∆° ti·ªÉu ƒë∆∞·ªùng"
    return f"X√°c su·∫•t m·∫Øc b·ªánh: {prob:.2f}\nK·∫øt qu·∫£: {result}"

# 9. Gradio UI
inputs = [
    gr.Slider(0, 20, step=1, label="Pregnancies"),
    gr.Slider(0, 200, step=1, label="Glucose"),
    gr.Slider(0, 140, step=1, label="BloodPressure"),
    gr.Slider(0, 100, step=1, label="SkinThickness"),
    gr.Slider(0, 900, step=1, label="Insulin"),
    gr.Slider(10, 70, step=0.1, label="BMI"),
    gr.Slider(0.05, 2.5, step=0.01, label="DiabetesPedigreeFunction"),
    gr.Slider(20, 100, step=1, label="Age")
]

output = gr.Textbox(label="K·∫øt qu·∫£ d·ª± ƒëo√°n")

app = gr.Interface(fn=predict_diabetes,
                   inputs=inputs,
                   outputs=output,
                   title="·ª®ng d·ª•ng d·ª± ƒëo√°n Ti·ªÉu ƒê∆∞·ªùng (ANN)",
                   description="Nh·∫≠p th√¥ng tin b·ªánh nh√¢n ƒë·ªÉ d·ª± ƒëo√°n.")

app.launch()

!python diabetes_app.py

# Commented out IPython magic to ensure Python compatibility.
# %pip install streamlit -q

# Commented out IPython magic to ensure Python compatibility.
# %%writefile diabetes_app.py
# import streamlit as st
# import numpy as np
# import pandas as pd
# import tensorflow as tf
# from sklearn.preprocessing import StandardScaler
# import joblib
# 
# # Assuming the scaler and model are saved
# # If not, you would need to load or redefine them here
# # For demonstration, let's assume a dummy scaler and model exist
# # In a real scenario, you would load the actual trained scaler and model
# 
# # Load the scaler (assuming it was saved after training)
# try:
#     scaler = joblib.load('scaler.pkl') # You would need to save the scaler after training
# except FileNotFoundError:
#     st.error("Scaler file not found. Please train and save the scaler.")
#     st.stop()
# 
# # Load the model (assuming it was saved after training)
# try:
#     model = tf.keras.models.load_model('diabetes_model.h5') # You would need to save the model after training
# except FileNotFoundError:
#     st.error("Model file not found. Please train and save the model.")
#     st.stop()
# 
# 
# st.title("Diabetes Prediction App")
# 
# st.sidebar.header("Patient Data")
# 
# def user_input_features():
#     pregnancies = st.sidebar.slider("Pregnancies", 0, 17, 1)
#     glucose = st.sidebar.slider("Glucose", 0, 200, 120)
#     blood_pressure = st.sidebar.slider("Blood Pressure", 0, 122, 70)
#     skin_thickness = st.sidebar.slider("Skin Thickness", 0, 99, 20)
#     insulin = st.sidebar.slider("Insulin", 0, 846, 80)
#     bmi = st.sidebar.slider("BMI", 0.0, 67.1, 25.0)
#     dpf = st.sidebar.slider("Diabetes Pedigree Function", 0.078, 2.42, 0.5)
#     age = st.sidebar.slider("Age", 21, 89, 30)
# 
#     data = {
#         "Pregnancies": pregnancies,
#         "Glucose": glucose,
#         "BloodPressure": blood_pressure,
#         "SkinThickness": skin_thickness,
#         "Insulin": insulin,
#         "BMI": bmi,
#         "DiabetesPedigreeFunction": dpf,
#         "Age": age,
#     }
#     features = pd.DataFrame(data, index=[0])
#     return features
# 
# input_df = user_input_features()
# 
# st.subheader("User Input Features")
# st.write(input_df)
# 
# # Scale the input features
# scaled_input = scaler.transform(input_df)
# 
# # Make prediction
# prediction = model.predict(scaled_input)
# 
# st.subheader("Prediction")
# prediction_proba = prediction[0][0]
# 
# st.write(f"Probability of Diabetes: {prediction_proba:.4f}")
# 
# if prediction_proba > 0.5:
#     st.write("Prediction: Likely to have Diabetes")
# else:
#     st.write("Prediction: Unlikely to have Diabetes")

import joblib

# Save the scaler
joblib.dump(scaler, 'scaler.pkl')

# Save the model
model.save('diabetes_model.h5')